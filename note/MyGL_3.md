## NDC (Normalized Device Coordinate)
整个OpenGL对标准坐标的定义和转换流程在这里忽略，仅从代码实现的角度做一遍梳理：

我们不从坐标系转换的角度去看整个流程，而是从更符合直觉的角度去思考，即不移动坐标系，转而移动模型，即所有这些矩阵都是在移动模型，坐标系从始至终只有世界坐标系

可以想象一个具体的坐标变换流程，首先模型的所有顶点都以坐标原点为中心定义，然后我们定义模型的缩放、旋转和平移参数，由这些参数构成的模型变换矩阵(model matrix)，将模型从原点移动到我们想让其在的地方

接着定义摄像机的位置和朝向(外属性)，由这些属性创建的摄像机移动矩阵(view matrix)，可以将摄像机从原点移动到我们想让它在的地方，但是程序最后会从OpenGL的默认摄像机位置和方向渲染物体(即位置(0,0,1)，朝向-z，上向量为+y)，那我们反向去使用这个矩阵，将模型变换回去(想象模型和摄像机粘在一起了，我们捏着摄像机，给它拖回到原点)，那么从默认摄像机渲染的视角，就等同于从我们定义的摄像机渲染的视角

最后是摄像机的画幅和FOV(内属性)，这里的透视投影(projection matrix)就不涉及坐标转换了，很好理解

如果你对坐标系的转换非常熟悉，上面的理解流程可能会有些冗余，那这时只要记住，对于两个坐标系A和B，在A系表示的B系的三个基构成的矩阵R_B，对于在B系表示的向量V_B，我们可以得到在A系表示的此向量V_A = R_B * V_B (仅对旋转)。那么对于世界坐标系W，模型坐标系M，摄像机坐标系C，我们首先明确，R_M和R_C是在W系的表示，那么对于M系的向量V_M，首先将其转换到系W: V_W = R_M * V_M，然后我们要做的是将其转换至系C，这是一个反向的过程，即: V_C = R_C' * V_W，这里的R_C'是R_C的转置

然后我们就能对整个坐标系转换在程序中的流程做一下梳理，首先需要一个模型类来记录模型的缩放、旋转和平移参数，然后提供一些接口方便的调节它们，并且返回计算的模型变换矩阵。接着是一个摄像机类，存储位置，朝向，画幅和FOV等，同样用接口返回view matrix和projection matrix。最后我们考虑在主程序中相乘这些变换矩阵，并传入shader与顶点相乘，在这里没必要将这些矩阵分别传入shader相乘，因为对于我们这个简单渲染器，这些矩阵的改变不会很频繁
### Mesh
我们首先创建一个基础的网格类Mesh，

### 四元数
